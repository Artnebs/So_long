/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   render_map.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anebbou <anebbou@student42.fr>             +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/15 10:00:00 by anebbou           #+#    #+#             */
/*   Updated: 2025/02/28 12:58:33 by anebbou          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

void	render_map(t_game *game)
{
	int	y;
	int	x;

	mlx_clear_window(game->mlx->id, game->mlx->win);
	y = 0;
	while (y < game->map->height)
	{
		x = 0;
		while (x < game->map->width)
		{
			render_tile(game, y, x);
			x++;
		}
		y++;
	}
	render_hud(game);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   check_path.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anebbou <anebbou@student42.fr>             +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/15 10:00:00 by anebbou           #+#    #+#             */
/*   Updated: 2025/02/28 12:59:58 by anebbou          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

static int	find_player_pos(t_map *map_data, int *p_x, int *p_y)
{
	if (map_data->player_count != 1)
	{
		ft_printf("Error\nNo valid player found.\n");
		return (0);
	}
	*p_x = map_data->player_x;
	*p_y = map_data->player_y;
	return (1);
}

static char	**duplicate_map(char **map_array, int height)
{
	char	**copy;
	int		i;

	copy = malloc(sizeof(char *) * (height + 1));
	if (!copy)
		return (NULL);
	i = 0;
	while (i < height)
	{
		copy[i] = ft_strdup(map_array[i]);
		if (!copy[i])
		{
			free_map(copy);
			return (NULL);
		}
		i++;
	}
	copy[i] = NULL;
	return (copy);
}

static void	flood_fill(char **map_copy, int x, int y, t_map *map_data)
{
	if (x < 0 || y < 0 || x >= map_data->height || y >= map_data->width)
		return ;
	if (map_copy[x][y] == '1' || map_copy[x][y] == 'X')
		return ;
	map_copy[x][y] = 'X';
	flood_fill(map_copy, x - 1, y, map_data);
	flood_fill(map_copy, x + 1, y, map_data);
	flood_fill(map_copy, x, y - 1, map_data);
	flood_fill(map_copy, x, y + 1, map_data);
}

static int	verify_reachable(char **map_copy, t_map *map_data)
{
	int	i;
	int	j;

	i = 0;
	while (i < map_data->height)
	{
		j = 0;
		while (j < map_data->width)
		{
			if (map_data->map_array[i][j] == 'C'
					|| map_data->map_array[i][j] == 'E')
			{
				if (map_copy[i][j] != 'X')
				{
					ft_printf("Error\nUnreachable C/E at (%d,%d).\n", i, j);
					return (0);
				}
			}
			j++;
		}
		i++;
	}
	return (1);
}

int	check_path(t_map *map_data)
{
	char	**map_copy;
	int		p_x;
	int		p_y;

	if (!find_player_pos(map_data, &p_x, &p_y))
		return (0);
	map_copy = duplicate_map(map_data->map_array, map_data->height);
	if (!map_copy)
	{
		ft_printf("Error\nFailed to copy map.\n");
		return (0);
	}
	flood_fill(map_copy, p_x, p_y, map_data);
	if (!verify_reachable(map_copy, map_data))
	{
		free_map(map_copy);
		return (0);
	}
	free_map(map_copy);
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_window.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anebbou <anebbou@student42.fr>             +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/15 10:00:00 by anebbou           #+#    #+#             */
/*   Updated: 2025/02/28 13:00:41 by anebbou          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

int	init_window(t_game *game)
{
	int	screen_width;
	int	screen_height;

	mlx_get_screen_size(game->mlx->id, &screen_width, &screen_height);
	game->mlx->win_width = game->map->width * TILE_SIZE;
	game->mlx->win_height = game->map->height * TILE_SIZE + HUD_HEIGHT;
	if (game->mlx->win_width > screen_width)
		game->mlx->win_width = screen_width;
	if (game->mlx->win_height > screen_height)
		game->mlx->win_height = screen_height;
	game->mlx->win = mlx_new_window(game->mlx->id,
			game->mlx->win_width, game->mlx->win_height, "so_long");
	if (!game->mlx->win)
	{
		ft_printf("Error\nFailed to create window.\n");
		return (1);
	}
	mlx_clear_window(game->mlx->id, game->mlx->win);
	render_map(game);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   monster_movement.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anebbou <anebbou@student42.fr>             +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/15 10:00:00 by anebbou           #+#    #+#             */
/*   Updated: 2025/02/28 14:06:09 by anebbou          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

void	move_monster(t_game *game, int x, int y)
{
	int		valid_dirs[4];
	int		count;
	int		dir;
	int		nx;
	int		ny;

	count = collect_valid_directions(game, x, y, valid_dirs);
	if (count == 0)
		return ;
	dir = valid_dirs[rand() % count];
	nx = x;
	ny = y;
	update_coordinates(dir, &nx, &ny);
	if (game->map->map_array[nx][ny] == 'P')
		return (lose_game(game));
	update_monster_position(game, x, y, dir);
}

void	move_monsters(t_game *game)
{
	int	x;
	int	y;

	x = game->map->height - 1;
	while (x >= 0)
	{
		y = game->map->width - 1;
		while (y >= 0)
		{
			if (game->map->map_array[x][y] == 'M')
			{
				move_monster(game, x, y);
			}
			y--;
		}
		x--;
	}
	render_map(game);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   texture_utils.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anebbou <anebbou@student42.fr>             +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/15 10:00:00 by anebbou           #+#    #+#             */
/*   Updated: 2025/02/28 13:03:01 by anebbou          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

void	check_textures(t_game *game)
{
	if (!game->textures)
		return ;
	if (!game->textures->wall)
		ft_printf("ERROR: Missing texture: wall\n");
	if (!game->textures->player)
		ft_printf("ERROR: Missing texture: player\n");
	if (!game->textures->collectible)
		ft_printf("ERROR: Missing texture: collectible\n");
	if (!game->textures->exit)
		ft_printf("ERROR: Missing texture: exit\n");
	if (!game->textures->floor)
		ft_printf("ERROR: Missing texture: floor\n");
	if (!game->textures->monster)
		ft_printf("ERROR: Missing texture: monster\n");
}

void	free_map(char **map_array)
{
	int	i;

	if (!map_array)
		return ;
	i = 0;
	while (map_array[i])
	{
		free(map_array[i]);
		i++;
	}
	free(map_array);
}

void	count_chars(t_map *map_data, int *player_count,
	int *exit_count, int *collect_count)
{
	int	i;
	int	j;

	i = 0;
	while (i < map_data->height)
	{
		j = 0;
		while (j < map_data->width)
		{
			if (map_data->map_array[i][j] == 'P')
			{
				map_data->player_x = i;
				map_data->player_y = j;
				(*player_count)++;
			}
			else if (map_data->map_array[i][j] == 'E')
				(*exit_count)++;
			else if (map_data->map_array[i][j] == 'C')
				(*collect_count)++;
			j++;
		}
		i++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   player_movement.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anebbou <anebbou@student42.fr>             +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/28 10:00:00 by anebbou           #+#    #+#             */
/*   Updated: 2025/02/28 13:04:22 by anebbou          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

static void	reset_player_position(t_map *map)
{
	while (map->map_array[map->player_x][map->player_y] == '1'
			|| map->map_array[map->player_x][map->player_y] == 'M')
	{
		map->player_x++;
		if (map->player_x >= map->height)
		{
			map->player_x = 0;
			map->player_y++;
			if (map->player_y >= map->width)
				map->player_y = 0;
		}
	}
}

void	respawn_player(t_game *game)
{
	game->map->player_lives--;
	if (game->map->player_lives <= 0)
	{
		ft_printf("Game Over! You lost all lives.\n");
		close_game(game);
		return ;
	}
	game->map->map_array[game->map->player_x][game->map->player_y] = '0';
	game->map->player_x = game->map->spawn_x;
	game->map->player_y = game->map->spawn_y;
	reset_player_position(game->map);
	game->map->map_array[game->map->player_x][game->map->player_y] = 'P';
	render_map(game);
}

static void	handle_move_result(t_game *game, int new_x, int new_y)
{
	if (game->map->map_array[new_x][new_y] == 'C')
	{
		game->map->collect_count--;
		game->map->map_array[new_x][new_y] = '0';
	}
	game->map->map_array[game->map->player_x][game->map->player_y] = '0';
	game->map->map_array[new_x][new_y] = 'P';
	game->map->player_x = new_x;
	game->map->player_y = new_y;
	game->map->moves++;
	ft_printf("Moves: %d | Lives: %d\n",
		game->map->moves, game->map->player_lives);
	render_map(game);
}

void	move_player(t_game *game, int dx, int dy)
{
	int	nx;
	int	ny;

	nx = game->map->player_x + dx;
	ny = game->map->player_y + dy;
	if (nx < 0 || ny < 0 || nx >= game->map->height || ny >= game->map->width)
		return ;
	if (game->map->map_array[nx][ny] == '1')
		return ;
	if (game->map->map_array[nx][ny] == 'M')
		return (respawn_player(game));
	if (game->map->map_array[nx][ny] == 'E' && game->map->collect_count == 0)
		return (win_game(game));
	if (game->map->map_array[nx][ny] == 'E')
		return ;
	handle_move_result(game, nx, ny);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anebbou <anebbou@student42.fr>             +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/15 10:00:00 by anebbou           #+#    #+#             */
/*   Updated: 2025/02/28 13:04:53 by anebbou          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

static int	init_all(t_game *game, int argc, char **argv)
{
	int	parse_ok;

	if (init_mlx(game))
		return (1);
	if (argc == 2)
	{
		parse_ok = parse_map(game, argv[1]);
		if (!parse_ok)
			return (1);
	}
	else
		load_default_map(game);
	if (!check_map_validity(game->map))
		return (1);
	if (init_window(game))
		return (1);
	if (load_textures(game))
		ft_printf("Warning: Textures not loaded.\n");
	check_textures(game);
	render_map(game);
	return (0);
}

int	main(int argc, char **argv)
{
	t_game	*game;

	game = ft_calloc(1, sizeof(t_game));
	if (!game)
	{
		ft_printf("Error\nAllocation failed.\n");
		return (1);
	}
	if (init_all(game, argc, argv))
		return (close_game(game));
	play_background_music();
	mlx_key_hook(game->mlx->win, handle_keypress, game);
	mlx_hook(game->mlx->win, 17, 0, close_game, game);
	mlx_loop(game->mlx->id);
	stop_background_music();
	return (close_game(game));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   music.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anebbou <anebbou@student42.fr>             +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/15 10:00:00 by anebbou           #+#    #+#             */
/*   Updated: 2025/03/03 11:35:52 by anebbou          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

void	play_background_music(void)
{
	system("mpg123 -q --loop -1 " MP3_FILE " &");
}

void stop_background_music(void)
{
	system("pkill -f mpg123");
	usleep(1000);
}

void	toggle_music(t_game *game)
{
	if (game->mute)
	{
		play_background_music();
		game->mute = 0;
	}
	else
	{
		stop_background_music();
		game->mute = 1;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   load_textures.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anebbou <anebbou@student42.fr>             +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/15 10:00:00 by anebbou           #+#    #+#             */
/*   Updated: 2025/02/28 13:06:44 by anebbou          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

static void	*load_texture(void *mlx, char *path)
{
	void	*img;
	int		width;
	int		height;

	img = mlx_xpm_file_to_image(mlx, path, &width, &height);
	if (!img)
		ft_printf("Warning\nFailed to load texture: %s\n", path);
	return (img);
}

int	load_textures(t_game *game)
{
	game->textures = ft_calloc(1, sizeof(t_textures));
	if (!game->textures)
		return (ft_printf("Error\nFailed to allocate textures struct.\n"), 1);
	game->textures->wall = load_texture(game->mlx->id, "textures/wall.xpm");
	game->textures->floor = load_texture(game->mlx->id, "textures/floor.xpm");
	game->textures->player = load_texture(game->mlx->id, "textures/player.xpm");
	game->textures->collectible = load_texture(game->mlx->id,
			"textures/collectible.xpm");
	game->textures->exit = load_texture(game->mlx->id, "textures/exit.xpm");
	game->textures->monster = load_texture(game->mlx->id,
			"textures/monster.xpm");
	game->textures->hud_moves = load_texture(game->mlx->id,
			"textures/hud_moves.xpm");
	game->textures->hud_collect = load_texture(game->mlx->id,
			"textures/hud_collect.xpm");
	game->textures->hud_lives = load_texture(game->mlx->id,
			"textures/hud_lives.xpm");
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   player_events.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anebbou <anebbou@student42.fr>             +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/28 10:00:00 by anebbou           #+#    #+#             */
/*   Updated: 2025/02/28 13:06:58 by anebbou          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

void	lose_game(t_game *game)
{
	game->map->player_lives--;
	if (game->map->player_lives <= 0)
	{
		ft_printf("Game Over! You lost all lives.\n");
		close_game(game);
		return ;
	}
	ft_printf("You got hit! Lives left: %d\n", game->map->player_lives);
	respawn_player(game);
}

int	handle_keypress(int keycode, t_game *game)
{
	if (keycode == KEY_ESC)
		close_game(game);
	else if (keycode == KEY_W)
		move_player(game, -1, 0);
	else if (keycode == KEY_S)
		move_player(game, 1, 0);
	else if (keycode == KEY_A)
		move_player(game, 0, -1);
	else if (keycode == KEY_D)
		move_player(game, 0, 1);
	else if (keycode == KEY_M)
		toggle_music(game);
	move_monsters(game);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exit_game.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anebbou <anebbou@student42.fr>             +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/15 10:00:00 by anebbou           #+#    #+#             */
/*   Updated: 2025/03/03 11:41:24 by anebbou          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

void	free_textures(t_game *game)
{
	if (!game->textures)
		return ;
	if (game->textures->wall)
		mlx_destroy_image(game->mlx->id, game->textures->wall);
	if (game->textures->floor)
		mlx_destroy_image(game->mlx->id, game->textures->floor);
	if (game->textures->player)
		mlx_destroy_image(game->mlx->id, game->textures->player);
	if (game->textures->collectible)
		mlx_destroy_image(game->mlx->id, game->textures->collectible);
	if (game->textures->exit)
		mlx_destroy_image(game->mlx->id, game->textures->exit);
	if (game->textures->monster)
		mlx_destroy_image(game->mlx->id, game->textures->monster);
	if (game->textures->hud_moves)
		mlx_destroy_image(game->mlx->id, game->textures->hud_moves);
	if (game->textures->hud_collect)
		mlx_destroy_image(game->mlx->id, game->textures->hud_collect);
	if (game->textures->hud_lives)
		mlx_destroy_image(game->mlx->id, game->textures->hud_lives);
	free(game->textures);
	game->textures = NULL;
}

int	close_game(t_game *game)
{
	if (!game)
		exit(0);
	stop_background_music();
	if (game->mlx && game->mlx->win)
		mlx_destroy_window(game->mlx->id, game->mlx->win);
	free_textures(game);
	if (game->map)
	{
		free_map(game->map->map_array);
		free(game->map);
	}
	if (game->mlx)
	{
		mlx_destroy_display(game->mlx->id);
		free(game->mlx->id);
		free(game->mlx);
	}
	free(game);
	exit(0);
	return (0);
}

void	win_game(t_game *game)
{
	ft_printf("You win!\n");
	close_game(game);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   render_tile.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anebbou <anebbou@student42.fr>             +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/28 10:00:00 by anebbou           #+#    #+#             */
/*   Updated: 2025/02/28 13:24:37 by anebbou          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

static void	draw_tile(t_game *game, int y, int x, int color)
{
	int	i;
	int	j;

	if (!game->mlx->win)
		return ;
	i = 0;
	while (i < TILE_SIZE)
	{
		j = 0;
		while (j < TILE_SIZE)
		{
			mlx_pixel_put(game->mlx->id, game->mlx->win,
				x * TILE_SIZE + j, (y * TILE_SIZE + i) + HUD_HEIGHT, color);
			j++;
		}
		i++;
	}
}

static void	put_texture_tile_helper(t_game *game, int y, int x, char c)
{
	if (c == '1')
		mlx_put_image_to_window(game->mlx->id, game->mlx->win,
			game->textures->wall, x * TILE_SIZE, (y * TILE_SIZE) + HUD_HEIGHT);
	else if (c == 'P')
		mlx_put_image_to_window(game->mlx->id, game->mlx->win,
			game->textures->player, x * TILE_SIZE,
			(y * TILE_SIZE) + HUD_HEIGHT);
	else if (c == 'C')
		mlx_put_image_to_window(game->mlx->id, game->mlx->win,
			game->textures->collectible, x * TILE_SIZE,
			(y * TILE_SIZE) + HUD_HEIGHT);
	else if (c == 'E')
		mlx_put_image_to_window(game->mlx->id, game->mlx->win,
			game->textures->exit, x * TILE_SIZE, (y * TILE_SIZE) + HUD_HEIGHT);
	else if (c == 'M')
		mlx_put_image_to_window(game->mlx->id, game->mlx->win,
			game->textures->monster, x * TILE_SIZE,
			(y * TILE_SIZE) + HUD_HEIGHT);
	else
		mlx_put_image_to_window(game->mlx->id, game->mlx->win,
			game->textures->floor, x * TILE_SIZE, (y * TILE_SIZE) + HUD_HEIGHT);
}

void	put_texture_tile(t_game *game, int y, int x, char c)
{
	if (c == 'm')
		c = 'M';
	put_texture_tile_helper(game, y, x, c);
}

static void	draw_tile_helper(t_game *game, int y, int x, char c)
{
	if (c == '1')
		draw_tile(game, y, x, COLOR_WALL);
	else if (c == 'P')
		draw_tile(game, y, x, COLOR_PLAYER);
	else if (c == 'C')
		draw_tile(game, y, x, COLOR_COLLECT);
	else if (c == 'E')
		draw_tile(game, y, x, COLOR_EXIT);
	else if (c == 'm' || c == 'M')
		draw_tile(game, y, x, COLOR_MONSTER);
	else
		draw_tile(game, y, x, COLOR_FLOOR);
}

void	render_tile(t_game *game, int y, int x)
{
	char	c;

	if (!game || !game->map || !game->map->map_array)
		return ;
	c = game->map->map_array[y][x];
	if (!game->textures)
		return ;
	if (!game->textures->wall || !game->textures->player
		|| !game->textures->collectible || !game->textures->exit
		|| !game->textures->floor || !game->textures->monster)
		draw_tile_helper(game, y, x, c);
	else
		put_texture_tile(game, y, x, c);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   monster_helpers.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anebbou <anebbou@student42.fr>             +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/28 13:02:02 by anebbou           #+#    #+#             */
/*   Updated: 2025/02/28 14:06:35 by anebbou          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

int	is_movable(t_game *game, int x, int y)
{
	char	tile;

	tile = game->map->map_array[x][y];
	return (tile == '0' || tile == 'C' || tile == 'P');
}

int	collect_valid_directions(t_game *game, int x, int y, int dirs[4])
{
	int	count;

	count = 0;
	if (x > 0 && is_movable(game, x - 1, y))
		dirs[count++] = 0;
	if (x < game->map->height - 1 && is_movable(game, x + 1, y))
		dirs[count++] = 1;
	if (y > 0 && is_movable(game, x, y - 1))
		dirs[count++] = 2;
	if (y < game->map->width - 1 && is_movable(game, x, y + 1))
		dirs[count++] = 3;
	return (count);
}

void	update_coordinates(int direction, int *nx, int *ny)
{
	if (direction == 0)
		*nx -= 1;
	else if (direction == 1)
		*nx += 1;
	else if (direction == 2)
		*ny -= 1;
	else if (direction == 3)
		*ny += 1;
}

void	update_monster_tile(t_game *game, int x, int y, char new_tile)
{
	if (new_tile == 'C')
		game->map->map_array[x][y] = 'm';
	else if (new_tile == '0')
		game->map->map_array[x][y] = 'M';
	else
		game->map->map_array[x][y] = new_tile;
}

void	update_monster_position(t_game *game, int x, int y, int direction)
{
	int	nx;
	int	ny;

	nx = x;
	ny = y;
	update_coordinates(direction, &nx, &ny);
	game->map->map_array[x][y] = '0';
	update_monster_tile(game, nx, ny, game->map->map_array[nx][ny]);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_mlx.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anebbou <anebbou@student42.fr>             +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/15 10:00:00 by anebbou           #+#    #+#             */
/*   Updated: 2025/02/28 13:16:07 by anebbou          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

int	init_mlx(t_game *game)
{
	game->mlx = ft_calloc(1, sizeof(t_mlx));
	if (!game->mlx)
	{
		ft_printf("Error\nFailed to allocate t_mlx.\n");
		return (1);
	}
	game->mlx->id = mlx_init();
	if (!game->mlx->id)
	{
		ft_printf("Error\nmlx_init() failed.\n");
		return (1);
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   resize_hook.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anebbou <anebbou@student42.fr>             +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/15 10:00:00 by anebbou           #+#    #+#             */
/*   Updated: 2025/02/28 13:16:17 by anebbou          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

int	resize_hook(int width, int height, t_game *game)
{
	if (width < 100 || height < 100)
		return (0);
	if (!game || !game->mlx || !game->mlx->win)
		return (0);
	mlx_destroy_window(game->mlx->id, game->mlx->win);
	game->mlx->win_width = width;
	game->mlx->win_height = height;
	game->mlx->win = mlx_new_window(game->mlx->id, width, height, "so_long");
	if (!game->mlx->win)
		return (0);
	mlx_clear_window(game->mlx->id, game->mlx->win);
	render_map(game);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   map_parsing.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anebbou <anebbou@student42.fr>             +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/15 10:00:00 by anebbou           #+#    #+#             */
/*   Updated: 2025/02/28 13:17:13 by anebbou          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

static void	copy_old_map(char **old_map, char **new_map, int count)
{
	int	i;

	i = 0;
	while (i < count)
	{
		new_map[i] = old_map[i];
		i++;
	}
}

static char	**allocate_and_copy_map(char **map, char **temp,
									int count, char *line)
{
	map = malloc(sizeof(char *) * (count + 2));
	if (!map)
	{
		free_map(temp);
		return (NULL);
	}
	copy_old_map(temp, map, count);
	map[count] = line;
	map[count + 1] = NULL;
	free(temp);
	return (map);
}

char	**read_map_file(char *filename)
{
	int		fd;
	int		count;
	char	*line;
	char	**map;
	char	**temp;

	fd = open(filename, O_RDONLY);
	if (fd < 0)
		return (NULL);
	map = NULL;
	count = 0;
	line = get_next_line(fd);
	while (line)
	{
		temp = map;
		map = allocate_and_copy_map(map, temp, count, line);
		if (!map)
			return (close(fd), NULL);
		count++;
		line = get_next_line(fd);
	}
	close(fd);
	return (map);
}

static int	set_map_dimensions(t_game *game)
{
	game->map->height = 0;
	while (game->map->map_array[game->map->height])
		game->map->height++;
	if (game->map->height > 0)
		game->map->width = ft_strlen(game->map->map_array[0]);
	if (game->map->height == 0 || game->map->width == 0)
	{
		free_map(game->map->map_array);
		free(game->map);
		game->map = NULL;
		return (0);
	}
	return (1);
}

int	parse_map(t_game *game, char *filename)
{
	game->map = ft_calloc(1, sizeof(t_map));
	if (!game->map)
		return (0);
	game->map->map_array = read_map_file(filename);
	if (!game->map->map_array)
	{
		free(game->map);
		game->map = NULL;
		return (0);
	}
	return (set_map_dimensions(game));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   load_default_map.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anebbou <anebbou@student42.fr>             +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/15 10:00:00 by anebbou           #+#    #+#             */
/*   Updated: 2025/02/28 13:18:13 by anebbou          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

static char	**append_line(char **map_array, int *rows, char *line, int fd)
{
	char	**temp;

	temp = realloc(map_array, sizeof(char *) * (*rows + 2));
	if (!temp)
	{
		ft_printf("Error: Failed to allocate memory for map array\n");
		free(map_array);
		close(fd);
		return (NULL);
	}
	map_array = temp;
	map_array[*rows] = line;
	(*rows)++;
	map_array[*rows] = NULL;
	return (map_array);
}

static char	**allocate_and_copy_map(char *filename, int *rows)
{
	char	**map_array;
	int		fd;
	char	*line;

	fd = open(filename, O_RDONLY);
	if (fd < 0)
	{
		ft_printf("Error: Failed to open file %s\n", filename);
		return (NULL);
	}
	map_array = NULL;
	*rows = 0;
	line = get_next_line(fd);
	while (line)
	{
		map_array = append_line(map_array, rows, line, fd);
		if (!map_array)
			return (NULL);
		line = get_next_line(fd);
	}
	close(fd);
	return (map_array);
}

void	load_default_map(t_game *game)
{
	t_map	*map;
	int		rows;

	map = ft_calloc(1, sizeof(t_map));
	if (!map)
	{
		ft_printf("Error: Failed to allocate memory for map struct\n");
		return ;
	}
	map->map_array = allocate_and_copy_map("maps/default_map.ber", &rows);
	if (!map->map_array)
	{
		ft_printf("Error: Failed to allocate and copy map\n");
		free(map);
		return ;
	}
	map->height = rows;
	map->width = ft_strlen(map->map_array[0]);
	map->player_lives = 3;
	map->spawn_x = 1;
	map->spawn_y = 1;
	game->map = map;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   map_validation.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anebbou <anebbou@student42.fr>             +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/15 10:00:00 by anebbou           #+#    #+#             */
/*   Updated: 2025/02/28 13:19:33 by anebbou          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

static int	fill_map_dimensions(t_map *map_data)
{
	int	i;
	int	len;

	i = 0;
	while (map_data->map_array[i])
	{
		len = ft_strlen(map_data->map_array[i]);
		while (len > 0 && (map_data->map_array[i][len - 1] == '\n'
			|| map_data->map_array[i][len - 1] == '\r'))
		{
			map_data->map_array[i][len - 1] = '\0';
			len--;
		}
		i++;
	}
	map_data->height = i;
	if (map_data->height == 0)
	{
		ft_printf("Error\nEmpty map.\n");
		return (0);
	}
	map_data->width = ft_strlen(map_data->map_array[0]);
	return (1);
}

int	check_rectangle(t_map *map_data)
{
	int	i;
	int	width;

	width = ft_strlen(map_data->map_array[0]);
	i = 1;
	while (i < map_data->height)
	{
		if ((int)ft_strlen(map_data->map_array[i]) != width)
		{
			ft_printf("Error\nMap is not a rectangle.\n");
			return (0);
		}
		i++;
	}
	return (1);
}

int	check_walls(t_map *map_data)
{
	int	i;

	i = 0;
	while (i < map_data->width)
	{
		if (map_data->map_array[0][i] != '1'
			|| map_data->map_array[map_data->height - 1][i] != '1')
		{
			ft_printf("Error\nMap is not surrounded by walls.\n");
			return (0);
		}
		i++;
	}
	i = 0;
	while (i < map_data->height)
	{
		if (map_data->map_array[i][0] != '1'
			|| map_data->map_array[i][map_data->width - 1] != '1')
		{
			ft_printf("Error\nMap is not surrounded by walls.\n");
			return (0);
		}
		i++;
	}
	return (1);
}

int	check_chars_count(t_map *map_data)
{
	int	player_count;
	int	exit_count;
	int	collect_count;

	player_count = 0;
	exit_count = 0;
	collect_count = 0;
	count_chars(map_data, &player_count, &exit_count, &collect_count);
	if (player_count != 1 || exit_count != 1 || collect_count < 1)
	{
		ft_printf("Error\nInvalid number of characters.\n");
		return (0);
	}
	map_data->player_count = player_count;
	map_data->exit_count = exit_count;
	map_data->collect_count = collect_count;
	return (1);
}

int	check_map_validity(t_map *map_data)
{
	if (!map_data->map_array)
	{
		ft_printf("Error\nInvalid map array.\n");
		return (0);
	}
	if (!fill_map_dimensions(map_data))
		return (0);
	if (!check_rectangle(map_data))
		return (0);
	if (!check_walls(map_data))
		return (0);
	if (!check_chars_count(map_data))
		return (0);
	if (!check_path(map_data))
		return (0);
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   render_hud.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anebbou <anebbou@student42.fr>             +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/28 10:00:00 by anebbou           #+#    #+#             */
/*   Updated: 2025/02/28 13:21:00 by anebbou          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

static void	draw_hud_line(t_game *game, int y)
{
	int	j;

	j = 0;
	while (j < game->mlx->win_width)
	{
		mlx_pixel_put(game->mlx->id, game->mlx->win, j, y, 0x000000);
		j++;
	}
}

static void	draw_hud_background(t_game *game)
{
	int	i;

	i = 0;
	while (i < HUD_HEIGHT)
	{
		draw_hud_line(game, i);
		i++;
	}
}

static void	draw_hud_textures(t_game *game)
{
	if (game->textures->hud_moves)
		mlx_put_image_to_window(game->mlx->id, game->mlx->win,
			game->textures->hud_moves, 10, 10);
	if (game->textures->hud_collect)
		mlx_put_image_to_window(game->mlx->id, game->mlx->win,
			game->textures->hud_collect, 120, 10);
	if (game->textures->hud_lives)
		mlx_put_image_to_window(game->mlx->id, game->mlx->win,
			game->textures->hud_lives, 230, 10);
}

static void	draw_hud_text(t_game *game, char *moves,
				char *collectibles, char *lives)
{
	mlx_string_put(game->mlx->id, game->mlx->win, 50, 20, 0xFFFFFF, moves);
	mlx_string_put(game->mlx->id, game->mlx->win, 160, 20, 0xFFFFFF,
		collectibles);
	mlx_string_put(game->mlx->id, game->mlx->win, 270, 20, 0xFFFFFF, lives);
}

void	render_hud(t_game *game)
{
	char	moves[10];
	char	collectibles[10];
	char	lives[10];

	if (!game || !game->map || !game->mlx || !game->textures)
		return ;
	ft_sprintf(moves, "%d", game->map->moves);
	ft_sprintf(collectibles, "%d", game->map->collect_count);
	ft_sprintf(lives, "%d", game->map->player_lives);
	draw_hud_background(game);
	draw_hud_textures(game);
	draw_hud_text(game, moves, collectibles, lives);
}
