#include "so_long.h"

/* Local helper: ensure exactly one player is found */
static int find_player_pos(t_map *map_data, int *p_x, int *p_y)
{
	if (map_data->player_count != 1)
		return (ft_printf("Error\nNo valid player found.\n"), 0);
	*p_x = map_data->player_x;
	*p_y = map_data->player_y;
	return (1);
}

/* Local helper: duplicate the map so we can flood fill it */
static char **duplicate_map(char **map_array, int height)
{
	char **copy;
	int i;

	copy = malloc(sizeof(char *) * (height + 1));
	if (!copy)
		return (NULL);
	i = 0;
	while (i < height)
	{
		copy[i] = ft_strdup(map_array[i]);
		if (!copy[i])
		{
			free_map(copy);
			return (NULL);
		}
		i++;
	}
	copy[i] = NULL;
	return (copy);
}

/* Recursive flood fill to mark reachable tiles */
static void flood_fill(char **map_copy, int x, int y, t_map *map_data)
{
	if (y < 0 || x < 0 || y >= map_data->width || x >= map_data->height)
		return;
	if (map_copy[x][y] == '1' || map_copy[x][y] == 'X')
		return;
	map_copy[x][y] = 'X';
	flood_fill(map_copy, x - 1, y, map_data);
	flood_fill(map_copy, x + 1, y, map_data);
	flood_fill(map_copy, x, y - 1, map_data);
	flood_fill(map_copy, x, y + 1, map_data);
}

/* Verify all 'C' and 'E' tiles are reachable (flood-filled) */
static int verify_reachable(char **map_copy, t_map *map_data)
{
	int i;
	int j;

	ft_printf("DEBUG: Verifying reachable tiles\n");
	i = 0;
	while (i < map_data->height)
	{
		j = 0;
		while (j < map_data->width)
		{
			if (map_data->map_array[i][j] == 'C' ||
				map_data->map_array[i][j] == 'E')
			{
				if (map_copy[i][j] != 'X')
					return (ft_printf("Error\nUnreachable C/E at (%d,%d).\n",
									  i, j),
							0);
			}
			j++;
		}
		i++;
	}
	return (1);
}

/* Public function: check if there's a valid path to all 'C' and 'E' */
int check_path(t_map *map_data)
{
	char **map_copy;
	int p_x;
	int p_y;

	ft_printf("DEBUG: Checking path\n");
	if (!find_player_pos(map_data, &p_x, &p_y))
		return (0);

	map_copy = duplicate_map(map_data->map_array, map_data->height);
	if (!map_copy)
		return (ft_printf("Error\nFailed to copy map.\n"), 0);

	flood_fill(map_copy, p_x, p_y, map_data);

	if (!verify_reachable(map_copy, map_data))
		return (free_map(map_copy), 0);

	free_map(map_copy);
	return (1);
}
#include "so_long.h"

/* Free all textures if they exist */
void free_textures(t_game *game)
{
	if (!game->textures)
		return;
	if (game->textures->wall)
		mlx_destroy_image(game->mlx->id, game->textures->wall);
	if (game->textures->floor)
		mlx_destroy_image(game->mlx->id, game->textures->floor);
	if (game->textures->player)
		mlx_destroy_image(game->mlx->id, game->textures->player);
	if (game->textures->collectible)
		mlx_destroy_image(game->mlx->id, game->textures->collectible);
	if (game->textures->exit)
		mlx_destroy_image(game->mlx->id, game->textures->exit);
	if (game->textures->monster)
		mlx_destroy_image(game->mlx->id, game->textures->monster);
	free(game->textures);
	game->textures = NULL;
}

/* Close the game, free all resources, and exit */
int close_game(t_game *game)
{
	if (!game)
		exit(0);
	stop_background_music();
	if (game->mlx && game->mlx->win)
		mlx_destroy_window(game->mlx->id, game->mlx->win);
	free_textures(game);
	if (game->map)
	{
		free_map(game->map->map_array);
		free(game->map);
		game->map = NULL;
	}
	if (game->mlx)
	{
		free(game->mlx);
		game->mlx = NULL;
	}
	free(game);
	exit(0);
	return (0);
}

/* Called when you reach 'E' with all collectibles */
void win_game(t_game *game)
{
	ft_printf("You win!\n");
	close_game(game);
}
#include "so_long.h"

/* Initialize the MLX library */
int init_mlx(t_game *game)
{
	ft_printf("DEBUG: Allocating MLX struct\n");
	game->mlx = ft_calloc(1, sizeof(t_mlx));
	if (!game->mlx)
		return (ft_printf("Error\nFailed to allocate t_mlx.\n"), 1);

	ft_printf("DEBUG: Initializing MLX\n");
	game->mlx->id = mlx_init();
	if (!game->mlx->id)
		return (ft_printf("Error\nmlx_init() failed.\n"), 1);

	return (0);
}
#include "so_long.h"

/*
** init_window:
**  - Uses mlx_get_screen_size to get max screen size (if available).
**  - Creates window, then calls render_map once.
*/
int init_window(t_game *game)
{
	int screen_width;
	int screen_height;

	ft_printf("DEBUG: Getting screen size\n");
	mlx_get_screen_size(game->mlx->id, &screen_width, &screen_height);

	ft_printf("DEBUG: screen_width=%d screen_height=%d\n", screen_width, screen_height);

	game->mlx->win_width = game->map->width * TILE_SIZE;
	game->mlx->win_height = game->map->height * TILE_SIZE;
	if (game->mlx->win_width > screen_width)
		game->mlx->win_width = screen_width;
	if (game->mlx->win_height > screen_height)
		game->mlx->win_height = screen_height;

	ft_printf("DEBUG: Creating window\n");
	game->mlx->win = mlx_new_window(game->mlx->id,
									game->mlx->win_width,
									game->mlx->win_height,
									"so_long");
	if (!game->mlx->win)
		return (ft_printf("Error\nFailed to create window.\n"), 1);

	ft_printf("DEBUG: Clearing window\n");
	mlx_clear_window(game->mlx->id, game->mlx->win);

	ft_printf("DEBUG: Rendering map\n");
	render_map(game);

	ft_printf("DEBUG: Window created %dx%d (Screen: %dx%d)\n",
			  game->mlx->win_width, game->mlx->win_height,
			  screen_width, screen_height);

	return (0);
}
#include "so_long.h"

/* Local helper: read default_map.ber and store in map_array */
static char **allocate_and_copy_map(char *filename, int *rows)
{
	char **map_array;
	int fd;
	char *line;

	ft_printf("DEBUG: Opening file %s\n", filename);
	fd = open(filename, O_RDONLY);
	if (fd < 0)
	{
		ft_printf("Error: Failed to open file %s\n", filename);
		return (NULL);
	}
	map_array = NULL;
	*rows = 0;

	while ((line = get_next_line(fd)))
	{
		char **temp = realloc(map_array, sizeof(char *) * (*rows + 2));
		if (!temp)
		{
			ft_printf("Error: Failed to allocate memory for map array\n");
			free(map_array);
			close(fd);
			return NULL;
		}
		map_array = temp;
		map_array[*rows] = line;
		(*rows)++;
		map_array[*rows] = NULL;
	}
	close(fd);
	ft_printf("DEBUG: File %s read successfully\n", filename);
	return (map_array);
}

/*
** load_default_map:
**  - Loads a larger default map with monsters (M).
**  - Player has 3 lives (map->player_lives = 3).
*/
void load_default_map(t_game *game)
{
	t_map *map;
	int rows;

	ft_printf("DEBUG: Loading default map\n");
	map = ft_calloc(1, sizeof(t_map));
	if (!map)
	{
		ft_printf("Error: Failed to allocate memory for map struct\n");
		return;
	}
	map->map_array = allocate_and_copy_map("maps/default_map.ber", &rows);
	if (!map->map_array)
	{
		ft_printf("Error: Failed to allocate and copy map\n");
		free(map);
		return;
	}
	map->height = rows;
	map->width = ft_strlen(map->map_array[0]);
	map->player_lives = 3;
	map->spawn_x = 1;
	map->spawn_y = 1;
	game->map = map;
	ft_printf("DEBUG: Default map loaded successfully\n");
}
#include "so_long.h"

static void *load_texture(void *mlx, char *path)
{
	void *img;
	int width;
	int height;

	img = mlx_xpm_file_to_image(mlx, path, &width, &height);
	if (!img)
		ft_printf("Warning\nFailed to load texture: %s\n", path);
	return img;
}

int load_textures(t_game *game)
{
	game->textures = ft_calloc(1, sizeof(t_textures));
	if (!game->textures)
		return (ft_printf("Error\nFailed to allocate textures struct.\n"), 1);

	game->textures->wall = load_texture(game->mlx->id, "textures/wall.xpm");
	game->textures->floor = load_texture(game->mlx->id, "textures/floor.xpm");
	game->textures->player = load_texture(game->mlx->id, "textures/player.xpm");
	game->textures->collectible = load_texture(game->mlx->id, "textures/collectible.xpm");
	game->textures->exit = load_texture(game->mlx->id, "textures/exit.xpm");
	game->textures->monster = load_texture(game->mlx->id, "textures/monster.xpm");

	/*
	** If absolutely all textures failed, we can warn the user
	** that only fallback colors will be drawn.
	*/
	if (!game->textures->wall && !game->textures->floor &&
		!game->textures->player && !game->textures->collectible &&
		!game->textures->exit && !game->textures->monster)
	{
		ft_printf("Warning\nAll textures failed to load; fallback colors only.\n");
	}

	return (0);
}
#include "so_long.h"

/* Local function: chain of init calls before the MLX loop */
static int init_all(t_game *game, int argc, char **argv)
{
	int parse_ok;

	ft_printf("DEBUG: Initializing MLX\n");
	if (init_mlx(game))
		return (1);

	if (argc == 2)
	{
		ft_printf("DEBUG: Parsing map file %s\n", argv[1]);
		parse_ok = parse_map(game, argv[1]);
		if (!parse_ok)
			return (1);
	}
	else
	{
		ft_printf("No map provided, using default map.\n");
		load_default_map(game);
	}

	ft_printf("DEBUG: Checking map validity\n");
	if (!check_map_validity(game->map))
		return (1);

	ft_printf("DEBUG: Initializing window\n");
	if (init_window(game))
		return (1);

	ft_printf("DEBUG: Loading textures\n");
	if (load_textures(game))
		ft_printf("Warning: Textures not loaded.\n");

	ft_printf("DEBUG: Checking textures\n");
	check_textures(game);

	ft_printf("DEBUG: Rendering map\n");
	render_map(game);

	return (0);
}

/* The main entry point */
int main(int argc, char **argv)
{
	t_game *game;

	ft_printf("DEBUG: Starting program\n");
	game = ft_calloc(1, sizeof(t_game));
	if (!game)
		return (ft_printf("Error\nAllocation failed.\n"), 1);

	ft_printf("DEBUG: Game struct allocated\n");

	if (init_all(game, argc, argv))
		return (close_game(game));

	ft_printf("DEBUG: Game initialized successfully\n");

	play_background_music();
	ft_printf("DEBUG: Music started\n");

	mlx_key_hook(game->mlx->win, handle_keypress, game);
	mlx_hook(game->mlx->win, 17, 0, close_game, game);

	ft_printf("DEBUG: Entering MLX loop\n");
	mlx_loop(game->mlx->id);

	ft_printf("DEBUG: Exiting MLX loop\n");
	stop_background_music();

	return (close_game(game));
}
#include "so_long.h"

/* Copy the old map pointers into the newly allocated array */
static void copy_old_map(char **old_map, char **new_map, int count)
{
	int i;

	i = 0;
	while (i < count)
	{
		new_map[i] = old_map[i];
		i++;
	}
}

/* Read a map file line by line into a NULL-terminated char** */
char **read_map_file(char *filename)
{
	int fd;
	int count;
	char *line;
	char **map;
	char **temp;

	fd = open(filename, O_RDONLY);
	if (fd < 0)
		return (ft_printf("Error\nFailed to open file: %s\n", filename), NULL);
	map = NULL;
	count = 0;
	line = get_next_line(fd);
	while (line)
	{
		temp = map;
		map = malloc(sizeof(char *) * (count + 2));
		if (!map)
		{
			free_map(temp);
			close(fd);
			return (ft_printf("Error\nmalloc failed.\n"), NULL);
		}
		copy_old_map(temp, map, count);
		map[count] = line;
		map[count + 1] = NULL;
		count++;
		free(temp);
		line = get_next_line(fd);
	}
	close(fd);
	return (map);
}

/* Free a map array */
void free_map(char **map_array)
{
	int i;

	if (!map_array)
		return;
	i = 0;
	while (map_array[i])
	{
		free(map_array[i]);
		i++;
	}
	free(map_array);
}

/* Parse the map from filename into game->map->map_array, set height/width */
int parse_map(t_game *game, char *filename)
{
	game->map = ft_calloc(1, sizeof(t_map));
	if (!game->map)
		return (ft_printf("Error\nFailed to allocate t_map.\n"), 0);

	game->map->map_array = read_map_file(filename);
	if (!game->map->map_array)
	{
		free(game->map);
		game->map = NULL;
		return (0);
	}
	game->map->height = 0;
	while (game->map->map_array[game->map->height])
		game->map->height++;
	if (game->map->height > 0)
		game->map->width = ft_strlen(game->map->map_array[0]);
	if (game->map->height == 0 || game->map->width == 0)
	{
		ft_printf("Error\nEmpty map.\n");
		free_map(game->map->map_array);
		free(game->map);
		game->map = NULL;
		return (0);
	}
	return (1);
}
#include "so_long.h"

/* Strip both '\n' and '\r' from line endings, then recalc length */
static int fill_map_dimensions(t_map *map_data)
{
	int i;
	int len;

	ft_printf("DEBUG: Filling map dimensions\n");
	i = 0;
	while (map_data->map_array[i])
	{
		len = ft_strlen(map_data->map_array[i]);
		ft_printf("DEBUG: Line %d length: %d\n", i, len);

		/* Remove trailing newline and carriage return characters */
		while (len > 0 &&
			   (map_data->map_array[i][len - 1] == '\n' ||
				map_data->map_array[i][len - 1] == '\r'))
		{
			map_data->map_array[i][len - 1] = '\0';
			len--;
		}
		i++;
	}
	map_data->height = i;
	if (map_data->height == 0)
		return (ft_printf("Error\nEmpty map.\n"), 0);
	map_data->width = ft_strlen(map_data->map_array[0]);
	ft_printf("DEBUG: Map dimensions - width: %d, height: %d\n",
			  map_data->width, map_data->height);
	return (1);
}

/* Check that every line has the same length => rectangle */
int check_rectangle(t_map *map_data)
{
	int i;
	int width;

	ft_printf("DEBUG: Checking if map is a rectangle\n");
	width = ft_strlen(map_data->map_array[0]);
	i = 1;
	while (i < map_data->height)
	{
		if ((int)ft_strlen(map_data->map_array[i]) != width)
			return (ft_printf("Error\nMap is not a rectangle.\n"), 0);
		i++;
	}
	return (1);
}

/* Check that top/bottom/left/right edges are all '1' */
int check_walls(t_map *map_data)
{
	int i;

	ft_printf("DEBUG: Checking map walls\n");
	i = 0;
	while (i < map_data->width)
	{
		if (map_data->map_array[0][i] != '1' ||
			map_data->map_array[map_data->height - 1][i] != '1')
			return (ft_printf("Error\nMap is not surrounded by walls.\n"), 0);
		i++;
	}
	i = 0;
	while (i < map_data->height)
	{
		if (map_data->map_array[i][0] != '1' ||
			map_data->map_array[i][map_data->width - 1] != '1')
			return (ft_printf("Error\nMap is not surrounded by walls.\n"), 0);
		i++;
	}
	return (1);
}

/* Count # of 'P', 'E', 'C' => must be exactly 1 'P', 1 'E', and >=1 'C' */
int check_chars_count(t_map *map_data)
{
	int i;
	int j;
	int player_count;
	int exit_count;
	int collect_count;

	ft_printf("DEBUG: Checking characters count\n");
	player_count = 0;
	exit_count = 0;
	collect_count = 0;
	i = 0;
	while (i < map_data->height)
	{
		j = 0;
		while (j < map_data->width)
		{
			if (map_data->map_array[i][j] == 'P')
			{
				map_data->player_x = i;
				map_data->player_y = j;
				player_count++;
			}
			else if (map_data->map_array[i][j] == 'E')
				exit_count++;
			else if (map_data->map_array[i][j] == 'C')
				collect_count++;
			j++;
		}
		i++;
	}
	if (player_count != 1 || exit_count != 1 || collect_count < 1)
		return (ft_printf("Error\nInvalid number of characters.\n"), 0);
	map_data->player_count = player_count;
	map_data->exit_count = exit_count;
	map_data->collect_count = collect_count;
	return (1);
}

/* Master function to check the map's validity from top to bottom */
int check_map_validity(t_map *map_data)
{
	ft_printf("DEBUG: Checking map validity\n");
	if (!map_data->map_array)
		return (ft_printf("Error\nInvalid map array.\n"), 0);
	if (!fill_map_dimensions(map_data))
		return (0);
	if (!check_rectangle(map_data))
		return (0);
	if (!check_walls(map_data))
		return (0);
	if (!check_chars_count(map_data))
		return (0);
	if (!check_path(map_data))
		return (0);
	return (1);
}
#include "so_long.h"

/* Helper function to move a single monster */
static void move_monster(t_game *game, int x, int y)
{
	int new_x = x;
	int new_y = y;
	int direction = rand() % 4;

	if (direction == 0 && x > 0) // Move up
		new_x--;
	else if (direction == 1 && x < game->map->height - 1) // Move down
		new_x++;
	else if (direction == 2 && y > 0) // Move left
		new_y--;
	else if (direction == 3 && y < game->map->width - 1) // Move right
		new_y++;

	if (game->map->map_array[new_x][new_y] == '0' || game->map->map_array[new_x][new_y] == 'P' || game->map->map_array[new_x][new_y] == 'C')
	{
		if (game->map->map_array[new_x][new_y] == 'P')
		{
			lose_game(game);
		}
		game->map->map_array[x][y] = '0';
	
		if (game->map->map_array[new_x][new_y] == 'C')
			game->map->map_array[x][y] = 'C';

		game->map->map_array[new_x][new_y] = 'M';
	}
}

/* Move all monsters in the game */
void move_monsters(t_game *game)
{
	int x;
	int y;

	for (x = 0; x < game->map->height; x++)
	{
		for (y = 0; y < game->map->width; y++)
		{
			if (game->map->map_array[x][y] == 'M')
			{
				move_monster(game, x, y);
			}
		}
	}
	render_map(game);
}#include "so_long.h"

void play_background_music(void)
{
	/* Loop the specified MP3 in the background using mpg123 */
	system("mpg123 -q --loop -1 " MP3_FILE " &");
}

void stop_background_music(void)
{
	/* Kill mpg123 process */
	system("pkill -f mpg123");
}

void toggle_music(t_game *game)
{
	if (game->mute)
	{
		play_background_music();
		game->mute = 0;
	}
	else
	{
		stop_background_music();
		game->mute = 1;
	}
}
#include "so_long.h"

/* If player is killed or steps on 'M', lose a life or end the game */
void respawn_player(t_game *game)
{
	game->map->player_lives--;
	if (game->map->player_lives <= 0)
	{
		ft_printf("Game Over! You lost all lives.\n");
		close_game(game);
	}
	else
	{
		game->map->map_array[game->map->player_x][game->map->player_y] = '0';
		game->map->player_x = game->map->spawn_x; // Reset to original spawn
		game->map->player_y = game->map->spawn_y;
		// Ensure the spawn position is walkable
		while (game->map->map_array[game->map->player_x][game->map->player_y] == '1' ||
			   game->map->map_array[game->map->player_x][game->map->player_y] == 'M')
		{
			game->map->player_x++;
			if (game->map->player_x >= game->map->height)
			{
				game->map->player_x = 0;
				game->map->player_y++;
				if (game->map->player_y >= game->map->width)
					game->map->player_y = 0;
			}
		}
		game->map->map_array[game->map->player_x][game->map->player_y] = 'P';
		render_map(game); // Refresh the map after respawn
	}
}

/* Helper after a valid move to a new tile */
static void handle_move_result(t_game *game, int new_x, int new_y)
{
	if (game->map->map_array[new_x][new_y] == 'C')
	{
		game->map->collect_count--;
		game->map->map_array[new_x][new_y] = '0';
	}

	game->map->map_array[game->map->player_x][game->map->player_y] = '0';
	game->map->map_array[new_x][new_y] = 'P';
	game->map->player_x = new_x;
	game->map->player_y = new_y;
	game->map->moves++;

	ft_printf("Moves: %d | Lives: %d\n", game->map->moves, game->map->player_lives);
	render_map(game);
}

/* Called by keypress to move the player in direction (dx, dy) */
void move_player(t_game *game, int dx, int dy)
{
	int nx = game->map->player_x + dx;
	int ny = game->map->player_y + dy;

	if (nx < 0 || ny < 0 || nx >= game->map->height || ny >= game->map->width)
		return;
	if (game->map->map_array[nx][ny] == '1')
		return; // Prevent walking into walls
	if (game->map->map_array[nx][ny] == 'M')
	{
		respawn_player(game); // Send player back to spawn
		return;
	}
	if (game->map->map_array[nx][ny] == 'E')
	{
		if (game->map->collect_count == 0)
			win_game(game);
		return;
	}
	handle_move_result(game, nx, ny);
}

/* If a monster steps on the player, we lose a life or end the game */
void lose_game(t_game *game)
{
	game->map->player_lives--;
	if (game->map->player_lives <= 0)
	{
		ft_printf("Game Over! You lost all lives.\n");
		close_game(game);
	}
	else
	{
		ft_printf("You got hit! Lives left: %d\n", game->map->player_lives);
		respawn_player(game); // Player respawns when hit
	}
}

/* The main key handler */
int handle_keypress(int keycode, t_game *game)
{
	if (keycode == KEY_ESC)
		close_game(game);
	else if (keycode == KEY_W)
		move_player(game, -1, 0);
	else if (keycode == KEY_S)
		move_player(game, 1, 0);
	else if (keycode == KEY_A)
		move_player(game, 0, -1);
	else if (keycode == KEY_D)
		move_player(game, 0, 1);
	else if (keycode == KEY_M)
		toggle_music(game);

	move_monsters(game);
	return (0);
}
#include "so_long.h"

/*
** draw_tile:
**  - Draws a fallback color tile using mlx_pixel_put if textures are missing.
*/
static void draw_tile(t_game *game, int y, int x, int color)
{
	int i;
	int j;

	if (!game->mlx->win)
		return;
	i = 0;
	while (i < TILE_SIZE)
	{
		j = 0;
		while (j < TILE_SIZE)
		{
			mlx_pixel_put(game->mlx->id,
						  game->mlx->win,
						  x * TILE_SIZE + j,
						  y * TILE_SIZE + i,
						  color);
			j++;
		}
		i++;
	}
}

/*
** put_texture_tile:
**  - Places the correct texture image into the window at (x,y).
**  - Called if the textures are loaded (no fallback).
*/
void put_texture_tile(t_game *game, int y, int x, char c)
{
	if (c == '1')
		mlx_put_image_to_window(game->mlx->id, game->mlx->win,
								game->textures->wall, x * TILE_SIZE, y * TILE_SIZE);
	else if (c == 'P')
		mlx_put_image_to_window(game->mlx->id, game->mlx->win,
								game->textures->player, x * TILE_SIZE, y * TILE_SIZE);
	else if (c == 'C')
		mlx_put_image_to_window(game->mlx->id, game->mlx->win,
								game->textures->collectible, x * TILE_SIZE, y * TILE_SIZE);
	else if (c == 'E')
		mlx_put_image_to_window(game->mlx->id, game->mlx->win,
								game->textures->exit, x * TILE_SIZE, y * TILE_SIZE);
	else if (c == 'M')
		mlx_put_image_to_window(game->mlx->id, game->mlx->win,
								game->textures->monster, x * TILE_SIZE, y * TILE_SIZE);
	else
		mlx_put_image_to_window(game->mlx->id, game->mlx->win,
								game->textures->floor, x * TILE_SIZE, y * TILE_SIZE);
}

/*
** render_tile:
**  - Decides whether to draw a texture or a fallback color tile.
*/
void render_tile(t_game *game, int y, int x)
{
	char c;

	printf("DEBUG: Inside render_tile for tile (%d, %d)\n", y, x);

	if (!game || !game->map || !game->map->map_array)
	{
		printf("ERROR: Game or map is NULL!\n");
		return;
	}

	c = game->map->map_array[y][x];
	printf("DEBUG: Tile character is '%c'\n", c);

	if (!game->textures)
	{
		printf("ERROR: game->textures is NULL!\n");
		return;
	}

	/*
	** If ANY essential texture is missing, we fallback to color drawing
	*/
	if (!game->textures->wall || !game->textures->player ||
		!game->textures->collectible || !game->textures->exit ||
		!game->textures->floor || !game->textures->monster)
	{
		printf("DEBUG: Using fallback colors for tile (%d, %d)\n", y, x);
		if (c == '1')
			draw_tile(game, y, x, COLOR_WALL);
		else if (c == 'P')
			draw_tile(game, y, x, COLOR_PLAYER);
		else if (c == 'C')
			draw_tile(game, y, x, COLOR_COLLECT);
		else if (c == 'E')
			draw_tile(game, y, x, COLOR_EXIT);
		else if (c == 'M')
			draw_tile(game, y, x, COLOR_MONSTER);
		else
			draw_tile(game, y, x, COLOR_FLOOR);
	}
	else
	{
		printf("DEBUG: Using textures for tile (%d, %d)\n", y, x);
		put_texture_tile(game, y, x, c);
	}
	printf("DEBUG: Finished rendering tile (%d, %d)\n", y, x);
}

/*
** render_map:
**  - Clears window, then draws each cell of map_array.
**  - Logs debug info and prints the Collectibles/Lives count to the terminal.
*/
void render_map(t_game *game)
{
	int y;
	int x;
	char hud[64];

	mlx_clear_window(game->mlx->id, game->mlx->win);

	y = 0;
	while (y < game->map->height)
	{
		x = 0;
		while (x < game->map->width)
		{
			render_tile(game, y, x);
			x++;
		}
		y++;
	}
	ft_sprintf(hud, "Collectibles: %d | Lives: %d",
			   game->map->collect_count, game->map->player_lives);

	mlx_string_put(game->mlx->id, game->mlx->win, 10, 10, 0xFFFFFF, hud);
}
#include "so_long.h"

int resize_hook(int width, int height, t_game *game)
{
	if (width < 100 || height < 100)
		return (ft_printf("Error\nToo small window.\n"), 0);
	if (!game || !game->mlx || !game->mlx->win)
		return (ft_printf("Error\nGame or window is NULL.\n"), 0);
	mlx_destroy_window(game->mlx->id, game->mlx->win);
	game->mlx->win_width = width;
	game->mlx->win_height = height;
	game->mlx->win = mlx_new_window(game->mlx->id, width, height, "so_long");
	if (!game->mlx->win)
		return (ft_printf("Error\nFailed to recreate window.\n"), 0);
	mlx_clear_window(game->mlx->id, game->mlx->win);
	render_map(game);
	return (0);
}
#include "so_long.h"

void check_textures(t_game *game)
{
	if (!game->textures)
		return;
	if (!game->textures->wall)
		ft_printf("ERROR: Missing texture: wall\n");
	if (!game->textures->player)
		ft_printf("ERROR: Missing texture: player\n");
	if (!game->textures->collectible)
		ft_printf("ERROR: Missing texture: collectible\n");
	if (!game->textures->exit)
		ft_printf("ERROR: Missing texture: exit\n");
	if (!game->textures->floor)
		ft_printf("ERROR: Missing texture: floor\n");
	if (!game->textures->monster)
		ft_printf("ERROR: Missing texture: monster\n");
}
