#include "so_long.h"

/*
** find_player_pos:
**  If needed, we could find the P here,
**  but we already store it in check_chars_count().
**  We'll keep it as a fallback if we want to ensure it was found.
*/
static int find_player_pos(t_map *map_data, int *p_x, int *p_y)
{
    if (map_data->player_count != 1)
        return (ft_printf("Error\nNo valid player found.\n"), 0);
    *p_x = map_data->player_x;
    *p_y = map_data->player_y;
    return (1);
}

/*
** duplicate_map:
**  - Returns a fresh copy of map_array to manipulate in flood_fill.
*/
static char **duplicate_map(char **map_array, int height)
{
    char **copy;
    int i;

    copy = (char **)malloc(sizeof(char *) * (height + 1));
    if (!copy)
        return (NULL);
    i = 0;
    while (i < height)
    {
        copy[i] = ft_strdup(map_array[i]);
        if (!copy[i])
        {
            free_map(copy);
            return (NULL);
        }
        i++;
    }
    copy[i] = NULL;
    return (copy);
}

/*
** flood_fill:
**  - Mark reachable cells as 'X'.
**  - We'll skip walls and already 'X' cells.
**  - Recursively fill up/down/left/right.
*/
static void flood_fill(char **map_copy, int x, int y, t_map *map_data)
{
    if (y < 0 || x < 0 || y >= map_data->width || x >= map_data->height)
        return;
    if (map_copy[x][y] == '1' || map_copy[x][y] == 'X')
        return;
    map_copy[x][y] = 'X'; // Mark visited
    flood_fill(map_copy, x - 1, y, map_data);
    flood_fill(map_copy, x + 1, y, map_data);
    flood_fill(map_copy, x, y - 1, map_data);
    flood_fill(map_copy, x, y + 1, map_data);
}

/*
** verify_reachable:
**  - Check if all 'C' and 'E' in the original map are reachable
**    (i.e. turned into 'X' in the map_copy).
*/
static int verify_reachable(char **map_copy, t_map *map_data)
{
    int i;
    int j;

    i = 0;
    while (i < map_data->height)
    {
        j = 0;
        while (j < map_data->width)
        {
            if (map_data->map_array[i][j] == 'C' || map_data->map_array[i][j] == 'E')
            {
                if (map_copy[i][j] != 'X')
                    return (ft_printf("Error\nUnreachable C or E at (%d,%d).\n", i, j), 0);
            }
            j++;
        }
        i++;
    }
    return (1);
}

/*
** check_path:
**  - Finds player P coords.
**  - Duplicates the map.
**  - Flood fill from the player's position.
**  - Verify that all 'C' and 'E' are reachable.
*/
int check_path(t_map *map_data)
{
    char **map_copy;
    int p_x;
    int p_y;

    if (!find_player_pos(map_data, &p_x, &p_y))
        return (0);
    map_copy = duplicate_map(map_data->map_array, map_data->height);
    if (!map_copy)
        return (ft_printf("Error\nFailed to copy map.\n"), 0);
    flood_fill(map_copy, p_x, p_y, map_data);
    if (!verify_reachable(map_copy, map_data))
    {
        free_map(map_copy);
        return (0);
    }
    free_map(map_copy);
    return (1);
}
#include "so_long.h"

/*
** free_textures:
** - Destroys each texture if not NULL.
** - Frees the textures struct.
*/
void free_textures(t_game *game)
{
    if (!game->textures)
        return;
    if (game->textures->wall)
        mlx_destroy_image(game->mlx->id, game->textures->wall);
    if (game->textures->floor)
        mlx_destroy_image(game->mlx->id, game->textures->floor);
    if (game->textures->player)
        mlx_destroy_image(game->mlx->id, game->textures->player);
    if (game->textures->collectible)
        mlx_destroy_image(game->mlx->id, game->textures->collectible);
    if (game->textures->exit)
        mlx_destroy_image(game->mlx->id, game->textures->exit);
    free(game->textures);
    game->textures = NULL;
}

/*
** close_game:
**  - Destroy window if it exists.
**  - Free textures, map array, the map struct, the mlx struct, and game itself.
**  - Exit(0).
**  - Return 0 so it can be used as a callback.
*/
int close_game(t_game *game)
{
    if (!game)
        exit(0);
    if (game->mlx)
    {
        if (game->mlx->win)
            mlx_destroy_window(game->mlx->id, game->mlx->win);
        free_textures(game);
    }
    if (game->map)
    {
        free_map(game->map->map_array);
        free(game->map);
        game->map = NULL;
    }
    if (game->mlx)
    {
        // If needed, we could also do: mlx_destroy_display(game->mlx->id);
        // but it depends on your system. Then free(game->mlx->id);
        free(game->mlx);
        game->mlx = NULL;
    }
    free(game);
    exit(0);
    return (0);
}

/*
** win_game:
**  - Called when the player reaches exit with all collectibles collected.
**  - Print "You win!" and close the game properly.
*/
void win_game(t_game *game)
{
    ft_printf("You win!\n");
    close_game(game);
}
#include "so_long.h"

/*
** init_mlx:
** - Allocates the t_mlx struct inside game->mlx.
** - Initializes MLX (game->mlx->id).
** - Does NOT create a window yet (that is done by init_window()).
** Return 0 on success, 1 on error.
*/
int init_mlx(t_game *game)
{
	game->mlx = (t_mlx *)ft_calloc(1, sizeof(t_mlx));
	if (!game->mlx)
	{
		ft_printf("Error\nFailed to allocate t_mlx.\n");
		return (1);
	}
	game->mlx->id = mlx_init();
	if (!game->mlx->id)
	{
		ft_printf("Error\nmlx_init() failed.\n");
		return (1);
	}
	return (0);
}

#include "so_long.h"

/*
** init_window:
** - Uses `mlx_get_screen_size` to get the max screen size.
** - Ensures the game fills the screen but maintains the aspect ratio.
*/
int init_window(t_game *game)
{
	int screen_width;
	int screen_height;

	// Get the max screen resolution
	mlx_get_screen_size(game->mlx->id, &screen_width, &screen_height);

	// Set window size based on map size (scaling)
	game->mlx->win_width = game->map->width * TILE_SIZE;
	game->mlx->win_height = game->map->height * TILE_SIZE;

	// Prevent exceeding screen limits
	if (game->mlx->win_width > screen_width)
		game->mlx->win_width = screen_width;
	if (game->mlx->win_height > screen_height)
		game->mlx->win_height = screen_height;

	// Create the window
	game->mlx->win = mlx_new_window(game->mlx->id, game->mlx->win_width, game->mlx->win_height, "so_long");
	if (!game->mlx->win)
		return (ft_printf("Error\nFailed to create window.\n"), 1);

	// Force a full re-render
	mlx_clear_window(game->mlx->id, game->mlx->win);
	render_map(game);

	ft_printf("DEBUG: Window created with size %dx%d (Screen: %dx%d)\n",
			  game->mlx->win_width, game->mlx->win_height, screen_width, screen_height);

	return (0);
}
#include "so_long.h"

static t_map *allocate_map(int rows)
{
	t_map *map;

	map = ft_calloc(1, sizeof(t_map));
	if (!map)
		return (NULL);
	map->map_array = ft_calloc(rows + 1, sizeof(char *));
	if (!map->map_array)
	{
		free(map);
		return (NULL);
	}
	return (map);
}

void load_default_map(t_game *game)
{
	static char *def_map[] = {
		"1111111111111111",
		"1P0000C000000001",
		"1011011011110111",
		"100001000000C0E1",
		"1011110111110101",
		"1000C00000000001",
		"1011011011110111",
		"1C0001000000C001",
		"1111111111111111",
		NULL};

	t_map *map;
	int rows;
	int i;

	rows = 0;
	while (def_map[rows])
		rows++;
	map = allocate_map(rows);
	if (!map)
		return;
	i = 0;
	while (i < rows)
	{
		map->map_array[i] = ft_strdup(def_map[i]);
		if (!map->map_array[i++])
		{
			free_map(map->map_array);
			free(map);
			return;
		}
	}
	map->height = rows;
	map->width = ft_strlen(def_map[0]);
	game->map = map;
}
#include "so_long.h"

/*
** load_textures:
** Try to load each .xpm file.
** If it fails, print an error but DON'T exit.
** We'll fallback to using colors in render_map().
** Return 0 on success, 1 if any texture fails.
*/
int load_textures(t_game *game)
{
	int width;
	int height;

	// Always allocate textures, even if we use color fallback
	game->textures = (t_textures *)ft_calloc(1, sizeof(t_textures));
	if (!game->textures)
	{
		ft_printf("Error\nFailed to allocate t_textures.\n");
		return (1);
	}

	// Load textures (will fail if files are missing)
	game->textures->wall = mlx_xpm_file_to_image(game->mlx->id, "textures/wall.xpm", &width, &height);
	if (!game->textures->wall)
		ft_printf("Warning\nFailed to load wall.xpm.\n");

	game->textures->player = mlx_xpm_file_to_image(game->mlx->id, "textures/player.xpm", &width, &height);
	if (!game->textures->player)
		ft_printf("Warning\nFailed to load player.xpm.\n");

	game->textures->collectible = mlx_xpm_file_to_image(game->mlx->id, "textures/collectible.xpm", &width, &height);
	if (!game->textures->collectible)
		ft_printf("Warning\nFailed to load collectible.xpm.\n");

	game->textures->exit = mlx_xpm_file_to_image(game->mlx->id, "textures/exit.xpm", &width, &height);
	if (!game->textures->exit)
		ft_printf("Warning\nFailed to load exit.xpm.\n");

	game->textures->floor = mlx_xpm_file_to_image(game->mlx->id, "textures/floor.xpm", &width, &height);
	if (!game->textures->floor)
		ft_printf("Warning\nFailed to load floor.xpm.\n");

	// If all textures are missing, return 1 to indicate fallback mode
	if (!game->textures->wall && !game->textures->player &&
		!game->textures->collectible && !game->textures->exit && !game->textures->floor)
	{
		ft_printf("Warning: No textures loaded. Using fallback colors.\n");
	}

	return (0);
}
#include "so_long.h"

/*
** copy_old_map:
** Helper to expand your map array by 1 line each time you read a new line.
*/
static void copy_old_map(char **old_map, char **new_map, int count)
{
    int i;

    i = 0;
    while (i < count)
    {
        new_map[i] = old_map[i];
        i++;
    }
}

/*
** read_map_file:
**  - Opens the file, reads line by line using get_next_line().
**  - Stores lines into a newly allocated char**.
**  - Returns the final NULL-terminated char** or NULL on error.
*/
char **read_map_file(char *filename)
{
    int fd;
    int count;
    char *line;
    char **map;
    char **temp;

    fd = open(filename, O_RDONLY);
    if (fd < 0)
    {
        ft_printf("Error\nFailed to open file: %s\n", filename);
        return (NULL);
    }
    map = NULL;
    count = 0;
    line = get_next_line(fd);
    while (line)
    {
        temp = map;
        map = (char **)malloc(sizeof(char *) * (count + 2));
        if (!map)
        {
            free_map(temp);
            close(fd);
            ft_printf("Error\nmalloc failed in read_map_file().\n");
            return (NULL);
        }
        copy_old_map(temp, map, count);
        map[count] = line; // line includes its '\n'
        map[count + 1] = NULL;
        count++;
        free(temp); // free old pointer (not its contents)
        line = get_next_line(fd);
    }
    close(fd);
    return (map);
}

/*
** free_map:
**  - Frees all strings and then the char** itself.
*/
void free_map(char **map_array)
{
    int i;

    if (!map_array)
        return;
    i = 0;
    while (map_array[i])
    {
        free(map_array[i]);
        i++;
    }
    free(map_array);
}

/*
** parse_map:
**  - Allocate t_map, read file into map_array, set width/height.
**  - Return 1 on success, 0 on error.
*/
int parse_map(t_game *game, char *filename)
{
    game->map = (t_map *)ft_calloc(1, sizeof(t_map));
    if (!game->map)
    {
        ft_printf("Error\nFailed to allocate t_map.\n");
        return (0);
    }
    game->map->map_array = read_map_file(filename);
    if (!game->map->map_array)
    {
        free(game->map);
        game->map = NULL;
        return (0);
    }

    // Prevent memory leak by checking before returning
    game->map->height = 0;
    while (game->map->map_array[game->map->height])
        game->map->height++;

    if (game->map->height > 0)
        game->map->width = ft_strlen(game->map->map_array[0]);

    // Check for empty map
    if (game->map->height == 0 || game->map->width == 0)
    {
        ft_printf("Error\nEmpty map.\n");
        free_map(game->map->map_array);
        free(game->map);
        game->map = NULL;
        return (0);
    }
    return (1);
}
#include "so_long.h"

/*
** fill_map_dimensions:
**  - Removes trailing '\n' if present.
**  - Sets map_data->height and map_data->width accordingly.
** Return 1 if okay, 0 if empty map.
*/
static int fill_map_dimensions(t_map *map_data)
{
    int i;
    int len;

    i = 0;
    while (map_data->map_array && map_data->map_array[i])
    {
        len = ft_strlen(map_data->map_array[i]);
        // Remove trailing newline if present
        if (len > 0 && map_data->map_array[i][len - 1] == '\n')
            map_data->map_array[i][len - 1] = '\0';
        i++;
    }
    map_data->height = i;
    if (map_data->height == 0)
        return (ft_printf("Error\nEmpty map.\n"), 0);
    map_data->width = ft_strlen(map_data->map_array[0]);
    return (1);
}

/*
** check_rectangle:
**  - Checks that all lines have the same width.
*/
int check_rectangle(t_map *map_data)
{
    int i;
    int first_width;

    first_width = map_data->width;
    i = 0;
    while (map_data->map_array[i])
    {
        if ((int)ft_strlen(map_data->map_array[i]) != first_width)
            return (ft_printf("Error\nMap is not rectangular.\n"), 0);
        i++;
    }
    return (1);
}

/*
** check_walls:
**  - Ensures first/last row are all '1'.
**  - Ensures first/last column are all '1'.
*/
int check_walls(t_map *map_data)
{
    int i;
    int last_row;

    last_row = map_data->height - 1;
    i = 0;
    // Top and bottom row
    while (i < map_data->width)
    {
        if (map_data->map_array[0][i] != '1' || map_data->map_array[last_row][i] != '1')
            return (ft_printf("Error\nMissing top/bottom walls.\n"), 0);
        i++;
    }
    // Left and right column
    i = 0;
    while (i < map_data->height)
    {
        if (map_data->map_array[i][0] != '1' || map_data->map_array[i][map_data->width - 1] != '1')
            return (ft_printf("Error\nMissing side walls.\n"), 0);
        i++;
    }
    return (1);
}

/*
** check_chars_count:
**  - Ensure exactly 1 player P, at least 1 exit E, at least 1 collect C.
**  - Check for invalid characters (other than 0,1,P,E,C,M).
*/
int check_chars_count(t_map *map_data)
{
    int i;
    int j;
    char c;

    i = 0;
    while (i < map_data->height)
    {
        j = 0;
        while (j < map_data->width)
        {
            c = map_data->map_array[i][j];
            if (c == 'P')
            {
                map_data->player_count++;
                map_data->player_x = i;
                map_data->player_y = j;
            }
            else if (c == 'E')
                map_data->exit_count++;
            else if (c == 'C')
                map_data->collect_count++;
            else if (c != '0' && c != '1' && c != 'M' && c != '\0')
                return (ft_printf("Error\nInvalid char '%c' in map.\n", c), 0);
            j++;
        }
        i++;
    }
    if (map_data->player_count != 1 || map_data->exit_count < 1 || map_data->collect_count < 1)
        return (ft_printf("Error\nNeed 1P, >=1E, >=1C.\n"), 0);
    return (1);
}

/*
** check_map_validity:
**  - Fills map dimensions (removing trailing newlines).
**  - Checks rectangle, walls, char counts.
**  - Then calls check_path() to ensure accessibility.
*/
int check_map_validity(t_map *map_data)
{
    if (!map_data->map_array)
        return (ft_printf("Error\nInvalid map array.\n"), 0);
    if (!fill_map_dimensions(map_data))
        return (0);
    if (!check_rectangle(map_data))
        return (0);
    if (!check_walls(map_data))
        return (0);
    if (!check_chars_count(map_data))
        return (0);
    if (!check_path(map_data))
        return (0);
    return (1);
}
#include "so_long.h"

/*
** handle_keypress:
**  - WASD to move.
**  - ESC to close.
*/
int handle_keypress(int keycode, t_game *game)
{
	if (keycode == KEY_ESC)
		close_game(game);
	else if (keycode == KEY_W)
		move_player(game, -1, 0);
	else if (keycode == KEY_S)
		move_player(game, 1, 0);
	else if (keycode == KEY_A)
		move_player(game, 0, -1);
	else if (keycode == KEY_D)
		move_player(game, 0, 1);
	return (0);
}

/*
** move_player:
**  - dx, dy = direction of movement in row/col.
**  - Check walls. If next cell is a wall '1', don't move.
**  - If next cell is 'C', decrement collect_count and change to '0'.
**  - If next cell is 'E' and collect_count == 0 => win_game().
**  - Otherwise just move and update 'P' position in the map array.
**  - Then re-render the map.
*/
void move_player(t_game *game, int dx, int dy)
{
	int new_x;
	int new_y;

	new_x = game->map->player_x + dx;
	new_y = game->map->player_y + dy;

	// Check boundaries
	if (new_x < 0 || new_y < 0 || new_x >= game->map->height || new_y >= game->map->width)
		return;

	// If it's a wall, ignore
	if (game->map->map_array[new_x][new_y] == '1')
		return;

	// If next cell is exit and we have no more collectibles, we win
	if (game->map->map_array[new_x][new_y] == 'E')
	{
		if (game->map->collect_count == 0)
			win_game(game);
		return;
	}

	// If next cell is a collectible, pick it up
	if (game->map->map_array[new_x][new_y] == 'C')
	{
		game->map->collect_count--;
		game->map->map_array[new_x][new_y] = '0';
	}

	// Move: set old position to '0', new position to 'P'
	game->map->map_array[game->map->player_x][game->map->player_y] = '0';
	game->map->map_array[new_x][new_y] = 'P';
	game->map->player_x = new_x;
	game->map->player_y = new_y;

	// Increment moves count
	game->map->moves++;
	ft_printf("Moves: %d\n", game->map->moves);

	// Re-render after movement
	render_map(game);
}
#include "so_long.h"

/*
** draw_tile:
**  - Draw a single TILE_SIZE x TILE_SIZE square using mlx_pixel_put().
**    We added a safety check and a debug print to help diagnose crashes.
*/
void draw_tile(t_game *game, int y, int x, int color)
{
	int i;
	int j;

	/* Safety check: make sure the window pointer is valid */
	if (!game->mlx->win)
	{
		ft_printf("DEBUG: draw_tile called but win is NULL!\n");
		return;
	}
	i = 0;
	while (i < TILE_SIZE)
	{
		j = 0;
		while (j < TILE_SIZE)
		{
			mlx_pixel_put(
				game->mlx->id,
				game->mlx->win,
				x * TILE_SIZE + j,
				y * TILE_SIZE + i,
				color);
			j++;
		}
		i++;
	}
}

/*
** render_map:
**  - Iterates over map_array and draws each cell.
**  - If textures are loaded (non-null), you use mlx_put_image_to_window().
**    Otherwise fallback to color placeholders using draw_tile().
**
** We've added a debug print in the fallback branch so you see exactly which tile
** is being drawn with colors.
*/
void render_map(t_game *game)
{
	int y;
	int x;

	y = 0;
	while (y < game->map->height)
	{
		x = 0;
		while (x < game->map->width)
		{
			/*
			** Force using colors when textures are missing:
			** If ANY texture pointer is missing, we go color fallback.
			*/
			if (!game->textures || !game->textures->wall ||
				!game->textures->player || !game->textures->collectible ||
				!game->textures->exit || !game->textures->floor)
			{
				ft_printf("DEBUG: fallback tile at y=%d x=%d -> %c\n",
						  y, x, game->map->map_array[y][x]);

				if (game->map->map_array[y][x] == '1') // Wall
					draw_tile(game, y, x, COLOR_WALL);
				else if (game->map->map_array[y][x] == 'P') // Player
					draw_tile(game, y, x, COLOR_PLAYER);
				else if (game->map->map_array[y][x] == 'C') // Collectible
					draw_tile(game, y, x, COLOR_COLLECT);
				else if (game->map->map_array[y][x] == 'E') // Exit
					draw_tile(game, y, x, COLOR_EXIT);
				else // Floor
					draw_tile(game, y, x, COLOR_FLOOR);
			}
			else
			{
				// **Otherwise, use textures**
				if (game->map->map_array[y][x] == '1' && game->textures->wall)
					mlx_put_image_to_window(game->mlx->id, game->mlx->win, game->textures->wall, x * TILE_SIZE, y * TILE_SIZE);
				else if (game->map->map_array[y][x] == 'P' && game->textures->player)
					mlx_put_image_to_window(game->mlx->id, game->mlx->win, game->textures->player, x * TILE_SIZE, y * TILE_SIZE);
				else if (game->map->map_array[y][x] == 'C' && game->textures->collectible)
					mlx_put_image_to_window(game->mlx->id, game->mlx->win, game->textures->collectible, x * TILE_SIZE, y * TILE_SIZE);
				else if (game->map->map_array[y][x] == 'E' && game->textures->exit)
					mlx_put_image_to_window(game->mlx->id, game->mlx->win, game->textures->exit, x * TILE_SIZE, y * TILE_SIZE);
				else if (game->textures->floor) // Default case: floor
					mlx_put_image_to_window(game->mlx->id, game->mlx->win, game->textures->floor, x * TILE_SIZE, y * TILE_SIZE);
			}
			x++;
		}
		y++;
	}
}
#include "so_long.h"

int resize_hook(int width, int height, t_game *game)
{
	ft_printf("DEBUG: Entering resize_hook. New size: %dx%d\n", width, height);

	// Validate dimensions
	if (width < 100 || height < 100 || width > 1920 || height > 1080)
		return (ft_printf("ERROR: Invalid width/height received (%d, %d)\n", width, height), 0);

	if (!game || !game->mlx || !game->mlx->win)
		return (ft_printf("ERROR: `game`, `game->mlx`, or `game->mlx->win` is NULL\n"), 0);

	// Destroy the old window
	mlx_destroy_window(game->mlx->id, game->mlx->win);

	// Set new dimensions
	game->mlx->win_width = width;
	game->mlx->win_height = height;

	// Recreate window
	game->mlx->win = mlx_new_window(game->mlx->id, game->mlx->win_width, game->mlx->win_height, "so_long");
	if (!game->mlx->win)
		return (ft_printf("ERROR: Failed to recreate window.\n"), 0);

	// Re-render the game
	mlx_clear_window(game->mlx->id, game->mlx->win);
	render_map(game);

	ft_printf("DEBUG: Window resized successfully.\n");
	return (0);
}
#include "so_long.h"

static int init_all(t_game *game, int argc, char **argv)
{
	if (init_mlx(game))
		return (1);

	// Ensure `game->map` is properly allocated
	game->map = ft_calloc(1, sizeof(t_map));
	if (!game->map)
		return (ft_printf("Error\nFailed to allocate t_map.\n"), 1);

	// Load map (either from file or default)
	if (argc == 2)
	{
		if (!parse_map(game, argv[1]))
			return (1);
	}
	else
	{
		ft_printf("No map provided, using default map.\n");
		load_default_map(game);
	}

	// Validate the loaded map
	if (!check_map_validity(game->map))
		return (1);

	// Set window size
	game->mlx->win_width = 1024;
	game->mlx->win_height = 768;

	if (init_window(game))
		return (1);

	// Load textures (fallback to colors if failed)
	if (load_textures(game))
		ft_printf("Warning: Textures not loaded.\n");

	// Ensure `game->map->map_array` exists before rendering
	if (!game->map->map_array)
		return (ft_printf("Error\nInvalid map array.\n"), 1);

	render_map(game);
	return (0);
}

int main(int argc, char **argv)
{
	t_game *game;

	game = ft_calloc(1, sizeof(t_game));
	if (!game)
		return (ft_printf("Error\nAllocation failed.\n"), 1);

	/* If init_all fails, close_game will free and exit. */
	if (init_all(game, argc, argv))
		return (close_game(game));

	/* Key hook to catch W,A,S,D or ESC */
	mlx_key_hook(game->mlx->win, handle_keypress, game);

	/* Hook for window close button (button X) */
	mlx_hook(game->mlx->win, 17, 0, close_game, game);


	//mlx_hook(game->mlx->win, ConfigureNotify, StructureNotifyMask, resize_hook, game);

	mlx_loop(game->mlx->id);
	return (close_game(game));
}
